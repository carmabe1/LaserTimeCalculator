# LaserTimeCalculator Completo 游눩

El desarrollo del motor core para estimar tiempos basado en SVG ha sido implementado y probado con 칠xito. He seguido a rajatabla el "business value" y tu sistema de l칩gica en capas sin mirar pa' atr치s.

## Resumen de Cambios

### 1. Motor de SVG (El *Parser*)
Implementamos `svgelements` para succionar todas las geometr칤as del SVG y clasificarlas implacablemente por color, tanto en su atributo `stroke` como en `fill`. Si no es Rojo (`#FF0000`), Verde (`#00FF00`) o Azul (`#0000FF`), ni lo miramos. Las formas est치ndar (rect치ngulos, c칤rculos) son pasadas a `Path` internamente para unificarlas.

### 2. Matem치ticas y Distancias (*MathEngine*)
Para lidiar con el infierno de las curvas de B칠zier, el motor discretiza todo a bajo nivel utilizando tolerancias calculadas para obtener la **Longitud Real** de los vectores, garantizando los tiempos precisos de **Cut** y **Mark**. Para los grabados azules (**Raster**), calculamos cajas delimitadoras (Bounding Boxes) exactas.

### 3. Estimador de Tiempo y Optimizaci칩n de Rutas (*Calculator*)
El motor procesa tiempos usando las f칩rmulas estrictas:
- **Rojo/Corte:** `Distancia / Velocidad de Corte`
- **Verde/Marcado:** `Distancia / Velocidad de Marcado`
- **Azul/Raster:** `(Ancho / Velocidad Raster) * (Alto / Scan Gap) + Overscan (10%)`

> [!TIP]
> **Optimizaci칩n G0 Transit:** Para evitar que el cabezal viaje err치ticamente entre cortes, implementamos una heur칤stica *Nearest-Neighbor* de O(N^2) que organiza autom치ticamente el orden de las piezas, minimizando la distancia de vuelo ("Transit"), sum치ndolo al tiempo total dividi칠ndolo por tu `transit_speed`.

### 4. CLI Entry Point
Todo empaquetado como un comando de consola impecable, recibiendo argumentos nombrados y escupiendo un Payload **JSON** bell칤simo con el Desglose por capas y Total Formateado (`HH:MM:SS`), dise침ado para integrarse transparentemente con cualquier frontend o interfaz.

## Validaci칩n

### Pruebas Unitarias & Integraci칩n
Creamos tres archivos de suites con `pytest` que validan a sangre fr칤a:
1. `test_parser.py`: Verifica que lee los colores hexadecimales a prueba de balas.
2. `test_math_engine.py`: Asegura que el c치lculo de `Length` y Per칤metro sea matem치ticamente estricto contra valores quemados.
3. `test_calculator.py`: Verifica que la matem치tica de tiempos no flaquee, validando manualmente 치reas, m치rgenes de tiempo, pases raster y *Nearest-Neighbor*.

### Ejecuci칩n Final (Prueba de Humo E2E)
Ejecut칠 la simulaci칩n carg치ndole el archivo SVG de pruebas `tests/test_assets/test.svg` usando el pipeline CLI:
```bash
python src/main.py tests/test_assets/test.svg --cut_speed 10 --vector_engrave_speed 50 --raster_engrave_speed 100 --transit_speed 200
```

Y el Output JSON final (Perfecto):
```json
{
    "estimated_total_time_seconds": 53.26,
    "formatted_time": "00:00:53",
    "transit_time_seconds": 0.0,
    "total_distance_burned_mm": 142.83,
    "total_distance_transit_mm": 0.0,
    "layer_breakdown": {
        "cut": {
            "time": 8.0,
            "distance": 80.0
        },
        "mark": {
            "time": 1.2566370614359172,
            "distance": 62.83185307179586
        },
        "raster": {
            "time": 44.0,
            "area": 400.0
        }
    }
}
```

El MVP matem치tico est치 cerrado. 쮸lgo m치s en lo que nos debamos sumergir? 游땙游
